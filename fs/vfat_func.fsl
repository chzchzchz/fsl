uint bytes_per_cluster() {
	bpb	b;
	b = disk.d_bpb;
	return b.sectors_per_cluster*b.bytes_per_sector;
}

uint bytes_per_sector() { return disk.d_bpb.bytes_per_sector; }

uint get_total_sectors()
{
	bpb	b;
	b = disk.d_bpb;
	if (b.total_sect16 != 0) return b.total_sect16;
	return b.total_sect32;
}

uint get_fat_sectors()
{
	bpb	b;
	b = disk.d_bpb;
	if (b.sectors_in_fat16 != 0) return b.sectors_in_fat16;
	return b.priv32.sectors_in_fat32;
}

uint get_fat_bytes() { return get_fat_sectors()*disk.d_bpb.bytes_per_sector; }

uint get_cluster_count()
{
	uint	fat_sectors;
	uint	total_sectors;
	uint	root_dir_sectors;
	uint	data_sectors;
	uint	resv_sectors;
	uint	cluster_c;
	uint	bps;
	bpb	b;

	b = disk.d_bpb;
	fat_sectors = get_fat_sectors();
	total_sectors  = get_total_sectors();
	bps = b.bytes_per_sector;

	root_dir_sectors = b.root_de_c * sizeof_bytes(fat_de);
	root_dir_sectors += bps - 1;
	root_dir_sectors /= bps;

	resv_sectors = b.reserved_sector_c;
	resv_sectors += b.fat_count*fat_sectors;
	resv_sectors += root_dir_sectors;

	data_sectors = total_sectors - resv_sectors;
	cluster_c = data_sectors / b.sectors_per_cluster;

	return cluster_c;
}

fat_type get_fat_type()
{
	uint	cluster_count;
	bpb	b;

	b = disk.d_bpb;
	if (b.sectors_in_fat16 == 0) return FAT_TYPE_FAT32;

	cluster_count = get_cluster_count();
	if (cluster_count < 4085) return FAT_TYPE_FAT12;
	else if (cluster_count < 65525) return FAT_TYPE_FAT16;
	return FAT_TYPE_FAT32;
}

bool is_fat12() {
	if (get_fat_type() == FAT_TYPE_FAT12) return true;
	return false;
}

bool is_fat16(){
	if (get_fat_type() == FAT_TYPE_FAT16) return true;
	return false;
}

bool is_fat32(){
	if (get_fat_type() == FAT_TYPE_FAT32) return true;
	return false;
}

uint get_fatent_bits()
{
	if (is_fat12()) return 12;
	if (is_fat16()) return 16;
	if (is_fat32()) return 32;
	return 0;
}

clusternum_t fat_next_ft(clusternum_t cn, fat_type ft, fat f)
{
	if (ft == FAT_TYPE_FAT32) return f._ent32[cn].cluster_num;
	else if (ft == FAT_TYPE_FAT16) return f._ent16[cn].cluster_num;
	else if (ft == FAT_TYPE_FAT12) return f._ent12[cn].cluster_num;
	return fsl_fail(1);
}

clusternum_t fat_next(clusternum_t cn)
{
	fat_type	ft;
	fat		f;
	f = disk.fats[0];
	ft = get_fat_type();
	return fat_next_ft(cn, ft, f);
}

bool is_cluster_avail(clusternum_t cn)
{
	clusternum_t	v;
	v = fat_next(cn);
	if (v == FAT_ENT_FREE) return true;
	return false;
}

clusternum_t fat_chain_nth_cnum(clusternum_t start_clus, uint i)
{
	clusternum_t	cur_cluster;
	fat_type	ft;
	fat		f;

	f = disk.fats[0];
	ft = get_fat_type();
	cur_cluster = start_clus;
	while (i > 1) {
		cur_cluster = fat_next_ft(cur_cluster, ft, f);
		i = i - 1;
	}

	return cur_cluster;
}

cluster fat_chain_nth(clusternum_t cn, uint i)
{
	clusternum_t	sel_cn;
	sel_cn = fat_chain_nth_cnum(cn, i);
	return get_cluster(sel_cn);
}

clusternum_t get_nth_cnum(fat_de de, uint i)
{
	clusternum_t	clus_start;
	clus_start = (de.first_cluster_hi << 16) + de.first_cluster_lo;
	return fat_chain_nth_cnum(clus_start, i);
}

cluster get_nth(fat_de de, uint i)
{
	clusternum_t	cn;
	cn = get_nth_cnum(de, i);
	return get_cluster(cn);
}

cluster get_cluster(clusternum_t cn) { return disk.clusters[cn-2]; }

bool is_back_ref(fat_de de)
{
	if (de.name[0] == '.') {
		if (de.name[1] == ' ') return true;
		if (de.name[1] == '.' && de.name[2] == ' ')
			return true;
	}
	return false;
}

bool is_lfn(fat_de de)
{
	if (de.attr == 0xf) return true;
	return false;
}

bool is_good_dir(fat_de de)
{
	if (de.file_size == 0xffffffff) return false;
	if ((DIR_MASK & de.attr) != ATTR_DIRECTORY) return false;
	if (de.name[0] == '.') {
		if (de.name[1] == ' ') return false;
		if (de.name[1] == '.' && de.name[2] == ' ')
			return false;
	}
	return true;
}

bool is_deleted(fat_de de)
{
	if (de.name[0] == DEL_FLAG || de.name[0] == 0) return true;
	return false;
}

uint fat_chain_count(clusternum_t start_clus)
{
	clusternum_t 	cur_clus;
	u32		count;

	count = 0;
	cur_clus = start_clus;
	while (is_valid_cnum(cur_clus) == true) {
		count++;
		cur_clus = fat_next(cur_clus);
	}

	return count;
}

uint de_cluster_count(fat_de de)
{
	u32	bpc;

	if (de.file_size == 0xffffffff) return 0;

	if ( (ATTR_DIRECTORY & de.attr) != 0)  {
		clusternum_t	first_clus;
		first_clus = de.first_cluster_lo + (de.first_cluster_hi << 16);
		return fat_chain_count(first_clus);
	}

	bpc = bytes_per_cluster();
	return ((de.file_size + bpc - 1) / bpc);
}

bool is_valid_cnum(clusternum_t cnum)
{
	fat_type	ft;

	if (cnum < FAT_START_ENT) return false;

	ft = get_fat_type();
	if (ft == FAT_TYPE_FAT12) {
		if (cnum > FAT12_MAX) return false;
		return true;
	} else if (ft == FAT_TYPE_FAT16) {
		if (cnum > FAT16_MAX) return false;
		return true;
	} else if (ft == FAT_TYPE_FAT32) {
		if (cnum > FAT32_MAX) return false;
		return true;
	}

	return false;
}
