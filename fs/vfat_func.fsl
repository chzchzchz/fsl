u64 assert_nonzero(u64 x) { if (x == 0) return fsl_fail(0); return x; }

uint bytes_per_cluster() {
	bpb	b = disk.d_bpb;
	return assert_nonzero(b.sectors_per_cluster*b.bytes_per_sector);
}

uint bytes_per_sector() { return disk.d_bpb.bytes_per_sector; }

uint get_total_sectors()
{
	bpb	b = disk.d_bpb;
	u32	total;
	if (b.total_sect16 != 0) total = b.total_sect16;
	else total = b.total_sect32;
	return assert_nonzero(total);
}

uint get_fat_sectors()
{
	bpb	b = disk.d_bpb;
	u32	sects;
	if (b.sectors_in_fat16 != 0) sects = b.sectors_in_fat16;
	else sects = b.priv32.sectors_in_fat32;
	return assert_nonzero(sects);
}

uint get_fat_bytes() {
	return assert_nonzero(get_fat_sectors()*disk.d_bpb.bytes_per_sector);
}

uint get_cluster_count()
{
	uint	fat_sectors;
	uint	total_sectors;
	uint	root_dir_sectors;
	uint	data_sectors;
	uint	resv_sectors;
	uint	cluster_c;
	uint	bps;
	bpb	b;

	b = disk.d_bpb;
	fat_sectors = get_fat_sectors();
	total_sectors  = get_total_sectors();
	bps = b.bytes_per_sector;

	root_dir_sectors = b.root_de_c * sizeof_bytes(fat_de);
	root_dir_sectors += bps - 1;
	root_dir_sectors /= bps;

	resv_sectors = b.reserved_sector_c;
	resv_sectors += b.fat_count*fat_sectors;
	resv_sectors += root_dir_sectors;

	data_sectors = total_sectors - resv_sectors;
	cluster_c = data_sectors / b.sectors_per_cluster;

	return assert_nonzero(cluster_c);
}

fat_type get_fat_type()
{
	uint	cluster_count;
	bpb	b = disk.d_bpb;

	if (b.sectors_in_fat16 == 0) return FAT_TYPE_FAT32;

	cluster_count = get_cluster_count();
	if (cluster_count < 4085) return FAT_TYPE_FAT12;
	else if (cluster_count < 65525) return FAT_TYPE_FAT16;
	return FAT_TYPE_FAT32;
}

bool is_fat12() {
	if (get_fat_type() == FAT_TYPE_FAT12) return true;
	return false;
}

bool is_fat16(){
	if (get_fat_type() == FAT_TYPE_FAT16) return true;
	return false;
}

bool is_fat32(){
	if (get_fat_type() == FAT_TYPE_FAT32) return true;
	return false;
}

uint get_fatent_bits()
{
	if (is_fat12()) return 12;
	if (is_fat16()) return 16;
	if (is_fat32()) return 32;
	return 0;
}

clusternum_t fat_next_ft(clusternum_t cn, fat_type ft, fat f)
{
	if (ft == FAT_TYPE_FAT32) return f._ent32[cn].cluster_num;
	else if (ft == FAT_TYPE_FAT16) return f._ent16[cn].cluster_num;
	else if (ft == FAT_TYPE_FAT12) return f._ent12[cn].cluster_num;
	return fsl_fail(1);
}

clusternum_t fat_next(clusternum_t cn)
{
	fat_type	ft = get_fat_type();
	fat		f = disk.fats[0];
	return fat_next_ft(cn, ft, f);
}

bool is_cluster_avail(clusternum_t cn)
{
	clusternum_t	v = fat_next(cn);
	if (v == FAT_ENT_FREE) return true;
	return false;
}

clusternum_t fat_chain_nth_cnum(clusternum_t start_clus, uint i)
{
	clusternum_t	cur_cluster;
	fat_type	ft = get_fat_type();
	fat		f = disk.fats[0];

	cur_cluster = start_clus;
	while (i > 1 && is_eof(cur_cluster) == false) {
		cur_cluster = fat_next_ft(cur_cluster, ft, f);
		i--;
	}

	return cur_cluster;
}

cluster fat_chain_nth(clusternum_t cn, uint i)
{
	clusternum_t	sel_cn;
	sel_cn = fat_chain_nth_cnum(cn, i);
	return get_cluster(sel_cn);
}

clusternum_t get_nth_cnum(fat_de de, uint i)
{
	clusternum_t	clus_start;
	clus_start = (de.first_cluster_hi << 16) + de.first_cluster_lo;
	return fat_chain_nth_cnum(clus_start, i);
}

cluster get_nth(fat_de de, uint i)
{
	clusternum_t	cn;
	cn = get_nth_cnum(de, i);
	return get_cluster(cn);
}

cluster get_cluster(clusternum_t cn) { return disk.clusters[cn-2]; }

bool is_back_ref(fat_de de)
{
	fat_short_name sn = de.fname;
	if (sn.name[0] == '.') {
		if (sn.name[1] == ' ') return true;
		if (sn.name[1] == '.' && sn.name[2] == ' ')
			return true;
	}
	return false;
}

bool is_lfn(fat_de de)
{
	if (de.attr == 0xf) return true;
	return false;
}

bool is_good_dir(fat_de de)
{
	if (de.file_size == 0xffffffff) return false;
	if ((DIR_MASK & de.attr) != ATTR_DIRECTORY) return false;
	if (is_back_ref(de)) return false;
	return true;
}

bool is_deleted(fat_de de)
{
	fat_short_name	sn = de.fname;
	u8		c = sn.name[0];
	if (c == DEL_FLAG || c == 0) return true;
	return false;
}

uint fat_chain_count(clusternum_t start_clus)
{
	clusternum_t 	cur_clus = start_clus;
	u32		count = 0;

	while (is_valid_cnum(cur_clus) == true) {
		count++;
		cur_clus = fat_next(cur_clus);
	}

	return count;
}

uint de_cluster_count_chain(fat_de de)
{
	clusternum_t	first_clus;
	first_clus = de.first_cluster_lo + (de.first_cluster_hi << 16);
	return fat_chain_count(first_clus);
}

uint de_cluster_count(fat_de de)
{
	u32	bpc;

	if (de.file_size == 0xffffffff) return 0;

	if ( (ATTR_DIRECTORY & de.attr) != 0)  {
		return de_cluster_count_chain(de);
	}

	bpc = bytes_per_cluster();
	return ((de.file_size + bpc - 1) / bpc);
}

bool is_valid_cnum(clusternum_t cnum)
{
	fat_type	ft;

	if (cnum < FAT_START_ENT) return false;

	ft = get_fat_type();
	if (ft == FAT_TYPE_FAT12) {
		if (cnum > FAT12_MAX) return false;
		return true;
	} else if (ft == FAT_TYPE_FAT16) {
		if (cnum > FAT16_MAX) return false;
		return true;
	} else if (ft == FAT_TYPE_FAT32) {
		if (cnum > FAT32_MAX) return false;
		return true;
	}

	return false;
}

bool is_eof(clusternum_t cnum) {
	if (get_fat_type() == FAT_TYPE_FAT12) {
		if (cnum == EOF_FAT12) return true;
		return false;
	}
	if (get_fat_type() == FAT_TYPE_FAT16) {
		if (cnum == EOF_FAT16) return true;
		return false;
	}

	if (get_fat_type() == FAT_TYPE_FAT32) {
		if (cnum == EOF_FAT32) return true;
		return false;
	}

	return false;
}
