const __FSL_FSNAME = vfat;
const LAST_LONG_ENTRY_MASK = 0x40;
const ATTR_READ_ONLY = 0x1;
const ATTR_HIDDEN = 0x02;
const ATTR_SYSTEM = 0x04;
const ATTR_VOLUME_ID = 0x08;
const ATTR_DIRECTORY = 0x10;
const ATTR_ARCHIVE = 0x20;
const ATTR_LONG_NAME_MASK = 0x3f; 
const ATTR_LONG_NAME = 	ATTR_READ_ONLY|ATTR_HIDDEN|ATTR_SYSTEM|ATTR_VOLUME_ID;

const BAD_FAT12 = 0xff7;
const BAD_FAT16 = 0xfff7;
const BAD_FAT32 = 0xfffffff7;

const EOF_FAT12 = 0xfff;
const EOF_FAT16 = 0xffff;
const EOF_FAT32 = 0xffffffff;

const DEL_FLAG = 0xe5;
const FAT12_MAX = 0xff4;
const FAT16_MAX = 0xfff4;
const FAT32_MAX = 0x0ffffff6;
const FAT_ENT_FREE = 0;
const FAT_START_ENT = 2;

type disk 
assert ( ? (d_bpb.bytes_per_sector & (512 - 1)) == 0)
assert ( ? d_bpb.reserved_sector_c > 0)
assert ( ? get_cluster_count(d_bpb) <= 
	((get_fat_bytes(d_bpb)*8)/get_fatent_bits(d_bpb)-2) )
{
	bpb		d_bpb;

	align_bytes(d_bpb.bytes_per_sector);
	skip_bytes(d_bpb.bytes_per_sector * (d_bpb.reserved_sector_c - 1));
	
	fat		fats[d_bpb.fat_count] fixed;
	
	align_bytes(d_bpb.bytes_per_sector);
	
	fat_de		root_dir[d_bpb.root_de_c] fixed;
	
	align_bytes(d_bpb.bytes_per_sector);

	cluster		clusters[get_cluster_count(d_bpb)] fixed;
}

uint bytes_per_cluster()
{
	return bpb.sectors_per_cluster*bpb.bytes_per_sector;
}

type cluster
{
	u8	data[bytes_per_cluster()];
}

uint fat_next(uint cluster_num)
{
	fat_type	ft;
	fat		f;

	ft = get_fat_type(bpb);
	f = disk.fats[0];

	if (ft == FAT_TYPE_FAT12) return f.ent12[cluster_num].cluster_num;
	else if (ft == FAT_TYPE_FAT16) return f.ent16[cluster_num].cluster_num;
	else if (ft == FAT_TYPE_FAT32) return f.ent32[cluster_num].cluster_num;

	return fsl_fail(1);
}

cluster get_nth(fat_de de, uint i)
{
	u32	cur_cluster;

	de = fat_de;
	cur_cluster = (de.first_cluster_hi << 16) + de.first_cluster_lo;
	/* follow clusters. Need while loops, better error handling */
	while (i > 1) {
		cur_cluster = fat_next(cur_cluster);
		i = i - 1;
	}

	return disk.clusters[cur_cluster];
}

type fat_dir(int num_ents)
{
	fat_de	de[num_ents] fixed;
}

bool is_valid_cnum(u32 cnum)
{
	fat_type	ft;

	ft = get_fat_type(bpb);
	if (ft == FAT_TYPE_FAT12) {
		if (cnum > FAT12_MAX)
			return false;
		return true;
	} else if (ft == FAT_TYPE_FAT16) {
		if (cnum > FAT16_MAX)
			return false;
		return true;
	} else if (ft == FAT_TYPE_FAT32) {
		if (cnum > FAT32_MAX)
			return false;
		return true;
	}

	return false;
}

uint de_cluster_count(fat_de de)
{
	u32	bpc;

	if ( (ATTR_DIRECTORY & de.attr) != 0)  {
		u32	cur_clus;
		u32	count;

		count = 0;
		cur_clus = de.first_cluster_lo + (de.first_cluster_hi << 16);

		while (is_valid_cnum(cur_clus) == true) {
			count++;
			cur_clus = fat_next(cur_clus);
		}

		return count;
	}

	bpc = bytes_per_cluster();
	return ((de.file_size + bpc - 1) / bpc);
}

const DIR_MASK = ATTR_DIRECTORY|ATTR_VOLUME_ID|LAST_LONG_ENTRY_MASK;

bool is_deleted(fat_de de)
{
	if (de.name[0] == DEL_FLAG || de.name[0] == 0)
		return true;
	return false;
}

type fat_de
assert (? is_deleted(this) == false)
virtual_if(
	? file_size != 0xffffffff && ((DIR_MASK & attr) == 0),
	cluster, i, 1, de_cluster_count(this), get_nth(this, i)) as vfile
virtual_if(
	? file_size != 0xffffffff && ((DIR_MASK & attr) == ATTR_DIRECTORY),
	fat_de,
	i, 1, de_cluster_count(this), get_nth(this, i)) as vdir
points_if(
	? first_cluster_hi != 0xffff,
	disk.clusters[(first_cluster_lo + (first_cluster_hi << 16))]) as clusters
points_if(
	? is_fat12(bpb) && first_cluster_hi != 0xffff && file_size > 0,
	disk.fats[0].ent12[(first_cluster_lo + (first_cluster_hi << 16))]) as clus12
points_if(
	? is_fat16(bpb) && first_cluster_hi != 0xffff && file_size > 0,
	disk.fats[0].ent16[(first_cluster_lo + (first_cluster_hi << 16))]) as clus16
points_if(
	? is_fat32(bpb) && first_cluster_hi != 0xffff && file_size > 0,
	disk.fats[0].ent32[(first_cluster_lo + (first_cluster_hi << 16))]) as clus32
{
	u8		name[8+3];	/* name + ext */
	u8		attr;
	u8		nters;	/* special NT data */
	u8		time_create_ms;
	u16		time_create_time;
	u16		time_create_date;
	u16		time_lastaccess_date;
	u16		first_cluster_hi;
	u16		time_write_time;
	u16		time_write_date;
	u16		first_cluster_lo;
	u32		file_size;
}

type fat_long_de 
assert (? (attr & ATTR_LONG_NAME_MASK) == ATTR_LONG_NAME)
assert (? first_cluster_lo == 0)
{
	u8	order;
	u8	name[10];
	u8	attr;
	u8	de_type;
	u8	chksum;
	u8	name2[12];
	u16	first_cluster_lo;
	u8	name3[4];
}

type bpb_16 {
	u8	drvnum;
	u8	resv1;
	u8	bootsig;
	u8	volid[4];
	u8	vollabel[11];
	u8	fs_str[8];
}

type bpb_32 {
	u32	sectors_in_fat32;
	u16	ext_flags;
	u16	fsver;
	u32	root_cluster;
	u16	fsinfo;
	u16	bkbootsector;
	u8	reserved[12];
	u8	drvnum;
	u8	resv1;
	u8	bootsig;
	u32	volid;
	u8	vollabel[11];
	u8	fs_str[8];
}

type bpb
assert (? is_fat12(this) || is_fat16(this) || is_fat32(this))
{
	u8		jmp[3];
	u8		oem_name[8];
	u16		bytes_per_sector;
	u8		sectors_per_cluster;
	u16		reserved_sector_c;
	u8		fat_count;
	u16		root_de_c;
	u16		total_sect16;
	u8		media;
	u16		sectors_in_fat16;
	u16		sec_per_track;
	u16		num_heads;
	u32		hidden_sec;
	u32		total_sect32;
//	assert_eq (from_base_bits(), 36*8);
	if (get_fat_type(bpb) == FAT_TYPE_FAT32) {
		bpb_32	priv32;
	} else {
		bpb_16	priv16;
	}
}

type fat_ent12
points_if(? cluster_num > 0 && cluster_num < BAD_FAT12, fat.ent12[cluster_num]) as next_fatent
points_if(? cluster_num > 0 && cluster_num < BAD_FAT12, disk.clusters[cluster_num]) as clus_data
{
	u12	cluster_num;
}

type fat_ent16
points_if(? cluster_num > 0 && cluster_num < BAD_FAT16, fat.ent16[cluster_num]) as next_fatent
points_if(? cluster_num > 0 && cluster_num < BAD_FAT16, disk.clusters[cluster_num]) as clus_data
{
	u16	cluster_num;
}

type fat_ent32
points_if(? cluster_num > 0 && cluster_num < BAD_FAT32, fat.ent32[cluster_num]) as next_fatent
points_if(? cluster_num > 0 && cluster_num < BAD_FAT32, disk.clusters[cluster_num]) as clus_data
{
	u32	cluster_num;
}

type fat 
free(ent16, disk.clusters, 0)
free(ent12, disk.clusters, 0)
free(ent32, disk.clusters, 0)
{ 
	if (is_fat12(bpb)) {
		fat_ent12	ent12[FAT_START_ENT+get_cluster_count(bpb)];
	} else if (is_fat16(bpb)) {
		fat_ent16	ent16[FAT_START_ENT+get_cluster_count(bpb)];
	} else if (is_fat32(bpb)) {
		fat_ent32	ent32[FAT_START_ENT+get_cluster_count(bpb)];
	} else {
		fsl_fail(2);
	}
	set_bytes(get_fat_sectors(bpb)*bpb.bytes_per_sector);
}


enum fat_type = {FAT_TYPE_FAT12, FAT_TYPE_FAT16, FAT_TYPE_FAT32} u8;

uint get_fat_sectors(bpb b)
{
	if (b.sectors_in_fat16 != 0)
		return b.sectors_in_fat16;
	return b.priv32.sectors_in_fat32;
}

uint get_fat_bytes(bpb b)
{
	return get_fat_sectors(b)*b.bytes_per_sector;
}


uint get_total_sectors(bpb b)
{
	if (b.total_sect16 != 0) 
		return b.total_sect16;
	return b.total_sect32;
}

uint get_cluster_count(bpb b)
{
	uint	fat_sectors;
	uint	total_sectors;
	uint	root_dir_sectors;
	uint	data_sectors;
	uint	resv_sectors;
	uint	cluster_c;
	uint	bps;

	fat_sectors = get_fat_sectors(b);
	total_sectors  = get_total_sectors(b);
	bps = b.bytes_per_sector;

	root_dir_sectors = b.root_de_c * sizeof_bytes(fat_de);
	root_dir_sectors += bps - 1;
	root_dir_sectors /= bps;

	resv_sectors = b.reserved_sector_c;
	resv_sectors += b.fat_count*fat_sectors;
	resv_sectors += root_dir_sectors;

	data_sectors = total_sectors - resv_sectors;
	cluster_c = data_sectors / b.sectors_per_cluster;

	return cluster_c;
}

fat_type get_fat_type(bpb b)
{
	uint cluster_count;

	cluster_count = get_cluster_count(b);
	if (cluster_count < 4085) 
		return FAT_TYPE_FAT12;
	else if (cluster_count < 65525)
		return FAT_TYPE_FAT16;
	return FAT_TYPE_FAT32;
}

uint get_fatent_bits(bpb b)
{
	if (is_fat12(b)) return 12;
	if (is_fat16(b)) return 16;
	if (is_fat32(b)) return 32;
	return 0;
}

bool is_fat12(bpb b) { 
	if (get_fat_type(b) == FAT_TYPE_FAT12) 
		return true;
	return false;
}

bool is_fat16(bpb b){ 
	if (get_fat_type(b) == FAT_TYPE_FAT16)
		return true;
	return false;
}

bool is_fat32(bpb b){ 
	if (get_fat_type(b) == FAT_TYPE_FAT32)
		return true; 
	return false;
}
