const __FSL_FSNAME = vfat;
const LAST_LONG_ENTRY_MASK = 0x40;
const ATTR_READ_ONLY = 0x1;
const ATTR_HIDDEN = 0x02;
const ATTR_SYSTEM = 0x04;
const ATTR_VOLUME_ID = 0x08;
const ATTR_DIRECTORY = 0x10;
const ATTR_ARCHIVE = 0x20;
const ATTR_LONG_NAME_MASK = 0x3f; 
const ATTR_LONG_NAME = 	ATTR_READ_ONLY|ATTR_HIDDEN|ATTR_SYSTEM|ATTR_VOLUME_ID;
/* fat values */
const BAD_FAT12 = 0xff7;
const BAD_FAT16 = 0xfff7;
const BAD_FAT32 = 0xfffffff7;
const EOF_FAT12 = 0xfff;
const EOF_FAT16 = 0xffff;
const EOF_FAT32 = 0xffffffff;
const FAT12_MAX = 0xff4;
const FAT16_MAX = 0xfff4;
const FAT32_MAX = 0x0ffffff6;
const FAT_ENT_FREE = 0;
const FAT_START_ENT = 2;

const DEL_FLAG = 0xe5;
const DIR_MASK = ATTR_DIRECTORY|ATTR_VOLUME_ID|LAST_LONG_ENTRY_MASK;

enum fat_type = {FAT_TYPE_FAT12, FAT_TYPE_FAT16, FAT_TYPE_FAT32} u8;

typedef clusternum_t = u32;

include "assert.fsl"
include "vfat_func.fsl"
include "vfat_type.fsl"
include "vfat_fsck.fsl"

clusternum_t get_cn_badfat() {
	if (is_fat12()) return BAD_FAT12;
	if (is_fat16()) return BAD_FAT16;
	return BAD_FAT32;
}

write write_fat(clusternum_t cn, clusternum_t val)
{
	write_fat_n(cn, val, 0) !
	write_fat_n(cn, val, 1) !
}

write write_fat_n(clusternum_t cn, clusternum_t val, uint n)
{
	disk.fats[n].ent12[cn].cluster_num <- val ? is_fat12() !
	disk.fats[n].ent16[cn].cluster_num <- val ? is_fat16() !
	disk.fats[n].ent32[cn].cluster_num <- val ? is_fat32() !
//	XXX not sure why this doesn't work right now
//	write_fat_n(cn, val, n + 1) ? n < disk.d_bpb.fat_count !
}

/* mark this as something we don't want people to take */
write block_alloc(clusternum_t cn) { write_fat(cn, get_cn_badfat()) ! }

/* restore to free pool */
write block_replace(clusternum_t cn) { write_fat(cn, FAT_ENT_FREE) ! }

// update de
write block_rel_update_de(fat_de de, clusternum_t new_cn)
{
	de.first_cluster_lo <- new_cn & 0x0fff	? is_fat12() !
	de.first_cluster_lo <- new_cn & 0xffff	? is_fat16() !
	de.first_cluster_lo <- new_cn & 0xffff	? is_fat32() !
	de.first_cluster_hi <- 0		? is_fat12() !
	de.first_cluster_hi <- 0		? is_fat16() !
	de.first_cluster_hi <- new_cn >> 16	? is_fat32() !
	// relocated a directory and must update its '.' entry
	block_rel_update_de(find_dot_de(de), new_cn)
		? is_de_dir(de) && is_back_ref(de) == false !
}

// update fat entry that points to this
write block_rel_update_fatent(fat_de de, uint f_clus_off, clusternum_t new_cn)
{
	write_fat(get_nth_cnum(de, f_clus_off - 1), new_cn) !
}

// point this to next fat entry
write block_rel_update_fatnext(fat_de de, uint f_clus_off, clusternum_t new_cn)
{
	write_fat(new_cn, get_nth_cnum(de, f_clus_off + 1)) !
}

/* link cluster into given file offset, assumes file offset... */
write block_relink(fat_de de, uint f_clus_off, clusternum_t new_cn)
{
	block_rel_update_de(de, new_cn) ? f_clus_off == 1 !
	block_rel_update_fatent(de, f_clus_off, new_cn) ? f_clus_off > 1 !
	block_rel_update_fatnext(de, f_clus_off, new_cn) !
}
