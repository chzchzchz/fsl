const __FSL_FSNAME = ext2;
const EXT2_NDIR_BLOCKS = 12;
const EXT2_GOOD_OLD_INODE_SIZE = 128;
const EXT2_INO_BAD = 1;
const EXT2_INO_ROOT = 2;
const EXT2_INO_LOADER = 5;
const EXT2_INO_FIRST = 11;

int get_block_size(ext2_sb sb)
{
	return (1024 << sb.s_log_block_sz);
}

int get_group_count(ext2_sb sb)
{
	return 1+(((sb.s_blocks_c-sb.s_first_data_block)-1)/sb.s_blks_per_grp);
}

int blocks_off(ext2_sb sb)
{
	int	group_bytes;
	int	group_blocks;

	group_bytes = get_group_count(sb)*sizeof_bytes(ext2_group_desc);
	group_blocks = (group_bytes+get_block_size(sb)-1)/get_block_size(sb);

	return 1 + sb.s_first_data_block + group_blocks;
}

int inode_table_block_count(ext2_sb sb)
{
	u32	needed_bytes;
	needed_bytes = sizeof_bytes(ext2_inode)*sb.s_inos_per_grp;
	return (needed_bytes+get_block_size(sb)-1)/get_block_size(sb);
}

ext2_inode ino_by_num(u32 ino_num)
{
	int	ino_grp;
	int	ino_grp_idx;
	int	ino_grp_blk;
	int	ino_grp_blk_idx;
	int	table_base;
	int	blk_sz;

	blk_sz = get_block_size(disk.sb);
	ino_grp = ino_num / ext2_sb.s_inos_per_grp;
	ino_grp_idx = ino_num % disk.sb.s_inos_per_grp;
	ino_grp_blk = (ino_grp_idx * sizeof_bytes(ext2_inode)) / blk_sz;
	ino_grp_blk_idx = (ino_grp_idx*(sizeof_bytes(ext2_inode))) % blk_sz;

	table_base = disk.grp_desc_table[ino_grp].inode_table;
	return disk.blocks[
		table_base + ino_grp_blk - blocks_off(ext2_sb)].ino_blk.ino[
			ino_grp_blk_idx];
}



ext2_inode get_inode(uint ino_num_logical)
{
	int	ino_num;
	int	grp_idx;
	int	ino_tab_idx;
	int	ino_tab_off;
	int	ino_idx;
	int	table_blk;
	int	blk_num;

	ino_num = ino_num_logical - 1;
	grp_idx = ino_num / ext2_sb.s_inos_per_grp;
	ino_tab_idx = ino_num % ext2_sb.s_inos_per_grp;
	ino_tab_off = ino_tab_idx / (get_block_size(ext2_sb)/EXT2_GOOD_OLD_INODE_SIZE);
	ino_idx = ino_tab_idx % (get_block_size(ext2_sb)/EXT2_GOOD_OLD_INODE_SIZE);
	table_blk = disk.grp_desc_table[grp_idx].inode_table;

	blk_num = (table_blk + ino_tab_off) - blocks_off(disk.sb);
	return disk.blocks[blk_num].ino_blk.ino[ino_idx];
}

type disk
assert (? sb.s_inodes_c >= EXT2_INO_FIRST)
assert (? sb.s_blks_per_grp <= get_block_size(sb)*8)
assert (? sb.s_inos_per_grp <= get_block_size(sb)*8)
{
	/* superblock is always located at byte offset 1024 from the beginning 
	 * of the file, block device or partition formated with Ext2 */
	skip_bytes(1024);
	ext2_sb		sb;

	align_bytes(get_block_size(sb));

	ext2_group_desc	grp_desc_table[get_group_count(sb)];
	align_bytes(get_block_size(sb));
	
	union {
		ext2_inode_block	ino_blk;
		ext2_bmp_blk		blk_bmp;
		ext2_bmp_ino		ino_bmp;
		ext2_data_block		data_blk;
		ext2_indir_block	indir_blk;
		ext2_biindir_block	biindir_blk;
		ext2_triindir_block	triindir_blk;
	}blocks[sb.s_blocks_c - (from_base_bits()/8)/get_block_size(sb)];
}

type ext2_indir_block
points_range(
	i, 0, (get_block_size(ext2_sb)/4)-1,
	disk.blocks[blk_ptr[i] - blocks_off(disk.sb)].data_blk)
{
	u32	blk_ptr[get_block_size(ext2_sb)/4];
}

type ext2_biindir_block
points_range(
	i, 0, (get_block_size(ext2_sb)/4)-1,
	disk.blocks[blk_ptr[i] - blocks_off(disk.sb)].indir_blk)
{
	u32	blk_ptr[get_block_size(ext2_sb)/4];
}

type ext2_triindir_block
points_range(
	i, 0, (get_block_size(ext2_sb)/4)-1,
	disk.blocks[blk_ptr[i] - blocks_off(disk.sb)].biindir_blk)
{
	u32	blk_ptr[get_block_size(ext2_sb)/4];
}

type ext2_inode_block
assert (? sizeof_bytes(ext2_inode_block) == get_block_size(ext2_sb))
{
	ext2_inode	ino[get_block_size(ext2_sb)/(sizeof_bits(ext2_inode)/8)];
}

type ext2_data_block
{
	u8	data[get_block_size(ext2_sb)];
}

type ext2_group_desc
points(disk.blocks[block_bmp - blocks_off(disk.sb) ].blk_bmp)
points(disk.blocks[inode_bmp - blocks_off(disk.sb)].ino_bmp)
points_range(
	i, 0, inode_table_block_count(disk.sb)-1, 
	disk.blocks[(inode_table + i) - blocks_off(disk.sb)].ino_blk)
sum(free_block_c)
sum(free_inode_c)
sum(used_dir_c)
assert(? sizeof_bytes(ext2_group_desc) == 32)
{
	u32	block_bmp;
	u32	inode_bmp;
	u32	inode_table;
	u16	free_block_c;
	u16	free_inode_c;
	u16	used_dir_c;
	u16	pad;
	u32	reserved[3];
}

type ext2_sb
sum(s_free_blocks_c)
sum(s_free_inodes_c)
assert(? sizeof_bytes(ext2_sb) == 1024)
{
	u32	s_inodes_c;
	u32	s_blocks_c;
	u32	s_r_blocks_c;		/* reserved blocks */
	u32	s_free_blocks_c;
	u32	s_free_inodes_c;
	u32	s_first_data_block;
	u32	s_log_block_sz;		/* block size (log)) */
	u32	s_log_frag_sz;
	u32	s_blks_per_grp;
	u32	s_frags_per_grp;
	u32	s_inos_per_grp;
	u32	s_mtime;		/* mount time */
	u32	s_wtime;		/* write time */
	u16	s_mnt_c;		/* mounts since last fsck */
	u16	s_max_mnt_c;		/* max mounts until fsck */
	u16	s_magic;
	u16	s_state;
	u16	s_errors;
	u16	s_minor_rev_level;
	u32	s_lastcheck;
	u32	s_checkinterval;
	u32	s_creator_os;
	u32	s_rev_level;
	u16	s_def_resuid;		/* uid for reserved blocks */
	u16	s_def_resgid;		/* gid for reserved blocks */
	/* these fields are for EXT2_DYNAMIC_REV */
	u32	s_first_ino;
	/* XXX ... */

	/* finally, padding */
	align_bytes(1024);
}

uint sect_to_blocks(u32 sect)
{
	return (sect*512) / get_block_size(ext2_sb);
}

uint num_direct_blocks(ext2_inode ino)
{
	u32	num_blks;

	num_blks = sect_to_blocks(ino.i_blocks_c);
	if (num_blks > EXT2_NDIR_BLOCKS)
		return EXT2_NDIR_BLOCKS;
	return num_blks;
}

uint blocks_per_indir()
{
	return get_block_size(ext2_sb)/4;
}

/* XXX add points-to here */
type ext2_inode
points_range(
	i, 0, num_direct_blocks(ext2_inode)-1,
	disk.blocks[i_block_direct[i] - blocks_off(disk.sb)].data_blk)
points_if(
	? sect_to_blocks(i_blocks_c) > EXT2_NDIR_BLOCKS, 
	disk.blocks[i_block_indir - blocks_off(disk.sb)].indir_blk)
points_if(
	? sect_to_blocks(i_blocks_c)> (EXT2_NDIR_BLOCKS + blocks_per_indir()),
	disk.blocks[i_block_biindir - blocks_off(disk.sb)].biindir_blk)
points_if(
	? sect_to_blocks(i_blocks_c) > 
		(EXT2_NDIR_BLOCKS + blocks_per_indir()*
			(1 + blocks_per_indir())),
	disk.blocks[i_block_triindir - blocks_off(disk.sb)].triindir_blk)
{
	u16	i_mode;	/* file mode */
	u16	i_uid;	/* low 16 bits of owner uid */
	u32	i_size;	/* size in bytes */
	u32	i_atime;
	u32	i_ctime;
	u32	i_mtime;
	u32	i_dtime;
	u16	i_gid;
	u16	i_links_c;
	u32	i_blocks_c;	/* number of 512b sectors */
	u32	i_flags;
	u32	i_osd_resv;
	u32	i_block_direct[EXT2_NDIR_BLOCKS];
	u32	i_block_indir;
	u32	i_block_biindir;
	u32	i_block_triindir;
	u32	i_gen;
	u32	i_file_acl;
	u32	i_dir_acl;
	u32	i_faddr;
	align_bytes(EXT2_GOOD_OLD_INODE_SIZE);
}

type ext2_dir_entry
points(ino_by_num(inode))
{
	u32	inode;		/* inode number */
	u16	rec_len;	/* de length */
	u8	name_len;
	u8	file_type;
	u8	name[name_len];
	align_bytes(rec_len);
}


/* XXX add points-to here */
type ext2_bmp_blk { u1	data[get_block_size(disk.sb)*8]; }
type ext2_bmp_ino { u1	data[get_block_size(disk.sb)*8]; }
