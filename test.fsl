// test comments

//
// test enum features
//
enum SOME_ENUM = { a, b, c };
enum SOME_ENUM2 = { a = 10, b = 10, c = 30 };

//
// test const features
//
const c1 = 1 + 1;
const c2[] = {1, 2, 3, 4};


//
//test the types
//
//with args
type t1_args(t x, t y, t z) { i16 a; }


type t1_args_preamble(t x, t y, t z) 
fcall1()
fcall2()
{ i16 a; }

// without args
type t2_noargs { i16 a; }

type t2_noargs_preamble
	fcall1()
	fcall2()
{ i16 b; }

type ptype(int i)
{
	i16	some_array[i];
}

type paramtype(i16 x, i16 y)
{
	i32	a[x];
	i32	b[y];
}

// more type stuff.. layout..
type t3
{
	if (x == y) {
		i16	p;
		i32	q;
	} else {
		i32	f;
	}

	align(SECTOR_SIZE);

	ptype(2)	a;

//	union {
//		i16	f;
//		i16	g;
//	} ugh;

//	union {
//		i16	f;
//		i8	g;
//	} ugh2[10];
	
	paramtype(x,y)	f;
	t_after		next_type;
}


//
// test functions
//
i16 hello(i16 r)
{
	i16	x;
	i16	y[10];

	x += 1;
	y[0] = x;

	if (x == y) {
		return x;
	} else if (z == y) {
		return z;
	} else {
		return a;
	}


	return z;
}

//
// this type makes sure that thunk-conversion works
//
type t_after
{
	i32	o;
}
